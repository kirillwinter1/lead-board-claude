# Правила разработки Lead Board

## О проекте

**Lead Board** — SaaS-продукт для управления IT-доставкой, планирования и обеспечения прозрачности.

Продукт работает поверх Jira и предоставляет:
- Отслеживание прогресса
- Агрегацию трудозатрат
- Планирование capacity
- Предсказуемость для команд и менеджмента

---

## Технологический стек

### Backend
- Java 21
- Spring Boot 3
- PostgreSQL
- Clean Architecture

### Frontend
- React + TypeScript
- Vite
- REST API

### Инфраструктура
- Docker Compose
- Atlassian OAuth 2.0 (3LO)

---

## Ключевые принципы (неизменяемые)

### 1. Jira — единственный источник истины
- Иерархия задач, статусы, оценки, worklogs — всё из Jira
- Lead Board НИКОГДА не модифицирует данные в Jira
- Lead Board хранит локальный кэш и overlay-данные (dirty estimates)

### 2. Backend — единственный источник расчётов
- Frontend НЕ вычисляет метрики: оценки, время, прогресс, алерты
- Frontend только отображает данные от backend
- Фильтрация/поиск/пагинация НЕ пересчитывают метрики на frontend

### 3. Конфигурируемость
- НЕ хардкодить Jira-специфику (статусы, поля, типы задач)
- Всё должно быть конфигурируемым через Company → JiraSpace
- Разные Jira-проекты могут иметь разные схемы

### 4. Multi-tenancy
- Конфигурация привязана к: Company → JiraSpace
- Компания может иметь несколько Jira-ключей с разными схемами
- Все сущности строго привязаны к родительскому уровню
- **Сведения о компании хранятся в конфиге** (не в коде)

### 5. Безопасность и RBAC
- Права проверяются на сервере для каждого API-вызова
- Никаких UI-only проверок
- Роли: COMPANY_ADMIN > JIRA_SPACE_ADMIN > TEAM_LEAD > TEAM_MEMBER

---

## Доменная модель

### Иерархия организации
```
Company
└── JiraSpace (Jira-проект)
    └── Team
        └── TeamMember
```

### Иерархия задач
```
Epic (принадлежит одной команде)
└── Story
    └── Sub-task (роли: Analytics, Development, Testing)
```

### Сущности

**Team:**
- id, name, jiraSpaceId
- jiraTeamValue (значение из Jira-поля Epic)
- leadAccountId, active

**TeamMember:**
- jiraAccountId (идентификатор из Atlassian)
- displayName, role (SA|DEV|QA), grade (Junior|Middle|Senior)
- hoursPerDay, active

---

## Правила расчёта

### Единицы времени
- 1 человеко-день = 8 часов (как в Jira)

### Прогресс
```
progress = min(logged_hours / estimated_hours, 1.0)
```
- Прогресс ограничен 100%
- Статус Done требует полного логирования времени
- Если Done, но logged < estimate → алерт качества данных

### Агрегация
- Sub-task → Story: сумма по ролям
- Story → Epic: агрегация по ролям
- Прогресс по ролям рассчитывается отдельно (Analytics/Dev/Testing)

### Оценки Epic
- На этапе планирования: dirty estimate из Lead Board
- После груминга: расчёт из Jira sub-tasks

---

## Правила синхронизации с Jira

### Инкрементальная синхронизация
- Использовать JQL с `updated >= lastSyncTime`
- Upsert-логика: вставка или обновление
- Запрет параллельных синхронизаций (RUNNING блокирует новый запуск)

### Защита локальных полей
При синхронизации НЕ перезаписывать:
- role
- grade
- hoursPerDay
- roughEstimateDays

### Отказоустойчивость
- Retry с backoff
- Rate-limit handling
- Idempotent writes

---

## Правила разработки

### Обязательно для каждой фичи

1. **Тесты обязательны**
   - Backend: JUnit5 для нового поведения
   - Frontend: smoke-тесты
   - Запустить все тесты перед завершением
   - Покрывать основные сценарии и edge cases
   - Тесты должны быть читаемыми и поддерживаемыми

2. **Запуск тестов**
   - Backend: `./gradlew test` или аналог
   - Frontend: `npm test`
   - Исправить до зелёного статуса
   - Не коммитить с падающими тестами

3. **Документация обязательна**
   - Обновить `ai-ru/FEATURES.md` — статус фичи, дата завершения
   - Обновить `ai-ru/README.md` — если добавлены новые API или UI
   - Для крупных фич — создать отдельный файл спецификации (F{N}_{NAME}.md)
   - Документировать API endpoints, параметры, примеры ответов
   - Коммитить документацию вместе с кодом

4. **Минимальное стабильное состояние**
   - После каждой фичи проект должен собираться и запускаться
   - Нельзя оставлять сломанные билды, TODO-заглушки, падающие тесты

### Структура кода

Предпочтительные границы модулей:
- `integration/jira` — API + адаптеры
- `domain` — сущности + правила
- `config` — резолюция + валидация
- `metrics` — вычисление метрик
- `planning` — capacity + автопланирование

### Валидация конфигурации

Резолюция конфигурации:
1. ScopeConfig (переопределения для JiraSpace)
2. CompanyConfig (дефолты компании)
3. System defaults (только безопасные)

Если маппинг отсутствует → чёткая ошибка с указанием проблемы.

### Хранение сведений о компании

Все сведения о компании должны храниться в конфигурации:
- Название компании
- Jira-подключения (base URL, credentials)
- Настройки JiraSpace (маппинги полей, статусов, типов задач)
- Роли и права доступа
- Параметры расчётов (hoursPerDay, capProgressAt100)

**Запрещено** хардкодить данные компании в исходном коде.

---

## Правила работы с ассетами

**ЗАПРЕЩЕНО** без явного указания:
- Модифицировать, заменять, переименовывать, перемещать, удалять изображения
- Генерировать замены для отсутствующих изображений
- Оптимизировать изображения

Путь к иконкам: `frontend/src/assets/icons/`

---

## API ошибки

Стандартные коды:
- 400 — невалидный payload
- 401 — не аутентифицирован
- 403 — нет доступа
- 404 — не найдено
- 409 — конфликт (например, дубликат jiraAccountId)
- 502 — Jira недоступна

---

## Чеклист завершения задачи

1. Добавлены тесты для нового/изменённого поведения
2. Запущены тесты backend + frontend
3. Исправлены падения, перезапуск до зелёного статуса
4. Обновлена документация (FEATURES.md, README.md, спецификации)
5. Указаны выполненные команды и их результат
6. Конфигурируемо (никаких хардкодов статусов/полей)
7. Миграции совместимы назад (или указана записка о миграции)
7. Observability: structured logs, метрики для sync/compute
